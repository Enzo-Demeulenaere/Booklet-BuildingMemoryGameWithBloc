
!! Adding Interaction

Now we will add interation to the game. We want to flip the card by clicking on them. 
Bloc supports such situation using two mechanisms: on one hand, event listeners handle events
and on the other hand, the communication between the model and view is managed via the registration to announcements
raised by the model.


!!! An event listener

[[[
BlElementEventListener subclass: #MgdCardEventListener
	instanceVariableNames: 'memoryGame'
	classVariableNames: ''
	package: 'Bloc-MemoryGame-Tutorial'
]]]

We add an instance variable ==memoryGame== holding a game model to the listener because 
we will need to access the model to react to event for example to update the game situation. 

[[[
MgdCardEventListener >> memoryGame: aGameModel
	memoryGame := aGameModel
]]]

Let us redefine the ==click:== method to raise a debugger. It will give us the occasion to introspect the system.

[[[
MgdCardEventListener >> clickEvent: anEvent
	self halt
]]]




!!! Adding event listeners

Now we should add the game event listener to each card because we want to know which card will be clicked and pass this 
information to the game model.


[[[
MgdGameElement >> newCardEventListener
	^ MgdCardEventListener new
]]]

[[[
MgdGameElement >> memoryGame: aGameModel
	memoryGame := aGameModel.
	self layout columnCount: memoryGame gridSize.
	memoryGame availableCards
		do: [ :aCard | 
			| cardElement |
			cardElement := self newCardElement card: aCard.
			cardElement addEventHandler: (self newCardEventListener memoryGame: aGameModel).
			self addChild: cardElement ]
]]]



+Debugging the clickEvent: anEvent method.>file://figures/ClickWithDebugger.png|width=100|label=figBoardFull+


Now the preview is not enough and we should create a window and embedded the game element. 
Then when you click on an card you should get a debugger as shown in Figure *@figBoardFull*.
[[[
| space grid game |
space := BlSpace new.
space extent: 420@420. 
game := MgdGameModel numbers.
grid := MgdGameElement2 new.
grid memoryGame: game. 
space root addChild: grid.
space show 
]]]


!!! Specialize clickEvent:
Now we can specialise the ==clickEvent:== method as follows: 
- we get the graphical element that receives the mouse click using the message ==currentTarget==. The message ==currentTarget== returns the element that receives an event.
- From this graphical card we access the card model and we pass this card model to the game model. 

[[[
MgdCardEventListener >> clickEvent: anEvent
	memoryGame chooseCard: anEvent currentTarget card
]]]

It means that the memory game model is changed but we do not see the visual effect of our actions.
Indeed this is normal. We never made sure that visual elements are listening to model changes. 
This is what we will do in the following chapter. 



!! Connecting the model to the UI

In this chapter, we will show how the domain is communicating with the user interface: the domain emit notifications
using announcements but does not refer to the UI. It is the visual elements that should register to the notifications and react accordingly.



!! Adding animation