!! Building card graphic elements

In this chapter we will build step by step the visual appearance of the cards. 

!!! Card graphical element


A graphic element is a subclass of the ==BlElement==. It simply has a reference to a card model.

[[[
BlElement subclass: #MgdCardElement
	instanceVariableNames: 'card'
	classVariableNames: ''
	package: 'Bloc-MemoryGame-Demo-Elements'
]]]

The message ==backgroundColor== is one of the customisation hooks defined in ==BlElement==. 
Let us define a nice color. 

[[[
MgdCardElement >> backgroundColor
	^ Color lightBlue
]]]

We mentioned the accessors since the setter will be place to hook registration for the communication between the model and the view.

[[[
MgdCardElement >> card
	^ card
]]]


[[[
MgdCardElement >> 	card: aMgCard
		card := aMgCard
]]]

We initialize it to get a
[[[
MgdCardElement >> 	initialize
	super initialize.
	self size: 80 @ 80.
	self card: MgdCardModel new
]]]

!!! Starting to draw a card

To define the visual properties of a graphic element we redefine the method ==drawPathOnSpartaCanvas:==.

(This method will be renamed ==drawPathOn:== in the future).

[[[
MgdCardElement >> drawPathOnSpartaCanvas: aCanvas

	super drawPathOnSpartaCanvas: aCanvas.
	aCanvas fill 
		paint: self backgroundColor;
		path: self boundsInLocal;
		draw
]]]

Note that if we forget to send the message draw the canvas will be set but it will not display the result. 

Now to see the result in Morphic we have to get a spartaForm as follows:
[[[
MgdRawCardElement new asSpartaForm
]]]

You can also use the the inspector as shown in Figure *@figInspecting0*. Here we create and inspect the graphic element and then we ask it form and look at it in the Morph pane (this is what the Preview pane is actually doing).

+A first extremely basic representation of face down card.>file://figures/Inspecting0.png|width=100|label=figInspecting0+


!!! Improving the card visual 

Instead of displaying a full rectangle, we want a better visual. 
Bloc offers a shape factory. This shape factory returns shape path (lines, rectangle, ellipse, circle...) that can be passed to the canvas using the message ==path:==. Other shapes can be easily added. 

For example with the following expression ==path: (aCanvas shape ellipse: self boundsInLocal)== we draw now a circle since the bounds of the receiver returns a square of 80. 

[[[
MgdCardElement >> drawPathOnSpartaCanvas: aCanvas
	
	| radius |
	super drawPathOnSpartaCanvas: aCanvas.
	radius := 12.
	aCanvas fill 
		paint: self backgroundColor;
		path: (aCanvas shape ellipse: self boundsInLocal);
		draw
]]]

For our card we would like to have a rounded rectangle so we use the ==roundedRectangle:radii:== factory message.

[[[
MgdCardElement >> drawPathOnSpartaCanvas: aCanvas
	
	| radius |
	super drawPathOnSpartaCanvas: aCanvas.
	radius := 12.
	aCanvas fill 
		paint: self backgroundColor;
		path: (aCanvas shape roundedRectangle: (self boundsInLocal)
		radii: (BlCornerRadii radius: 12));
		draw
]]]

You should get then a visual aspect close to the one shown in Figure *@figrounded1*.


+A rounded card.>file://figures/CardRounded1.png|width=60|label=figrounded1+



!!! Preparing flipping

We define now two methods 

[[[
MgdCardElement >> drawBacksideOn: aCanvas
	"nothing for now"
]]]

[[[
MgdCardElement >> drawFlippedOnCanvas: aCanvas
	"nothing for now"
]]]

And we refactor ==drawPathOnSpartaCanvas:== as follows: 
we extract the common part into a separate method. 
[[[
MgdCardElement >> drawCommonOnCanvas: aCanvas
	| radius |
	super drawPathOnSpartaCanvas: aCanvas.
	radius := 12.
	aCanvas fill
		paint: self backgroundColor;
		path: (aCanvas shape roundedRectangle: self boundsInLocal radii: (BlCornerRadii radius: 12));
		draw.
]]]

Finally, ==drawPathOnSpartaCanvas:== logic is at the same conceptual level. 

[[[
MgdCardElement >> drawPathOnSpartaCanvas: aCanvas
	super drawPathOnSpartaCanvas: aCanvas.
	self drawCommonOnCanvas: aCanvas.
	self card flipped
		ifTrue: [ self drawFlippedOnCanvas: aCanvas ]
		ifFalse: [ self drawBacksideOn: aCanvas ]
]]]

Now we are ready to implement the backside and flipped side

!!! Adding a cross

Now we are ready to define the backside of our card. We will start by drawing a line. To draw a line we should provide a like as a path. In Bloc this can be done either that passing a Path object or asking the canvas for its shape factory. 
The shape factory encapsulate the logic of shapes. This is what we do below with the expression ==path: (aCanvas shape line: 0 @ 0 to: self extent)==. The message ==shape== returns a ShapeFactory and that ask this factory to produce a path to produce a line. 

[[[
MgdCardElement >> drawBacksideOn: aCanvas
	aCanvas stroke
		paint: Color paleBlue;
		path: (aCanvas shape line: 0 @ 0 to: self extent);
		draw
]]]


Once this method defined, refresh the inspector and you should get a card as in Figure *@figOneLIne*.

+A rounded card with half of the cross.>file://figures/CardOneLine.png|width=60|label=figOneLIne+






!!! Lines and corners reconciled

In Figure *@figOneLIne* we see that the line is not clipped to the corners. We should address this. 
This is the way we did it for now. 

[[[
MgdCardElement >> drawBacksideOn: aCanvas
	| radiusOffset |
	radiusOffset := 12 / Float pi.
	aCanvas stroke
		paint: Color gray;
		width: 3;
		path: (aCanvas shape 
				line: radiusOffset @ radiusOffset 
				to: self extent - radiusOffset);
		draw
]]]

Once you change the method ==drawBacksideOn:== and refresh you should get a card as displayed in Figure *@figClipped*.
+Clipping line.>file://figures/CardClipped.png|width=60|label=figClipped+

!!! Full cross clipped

Now we can add the line to build a full cross. Our solution is defined as follows: 

[[[
MgdCardElement >> drawBacksideOn: aCanvas
	| radiusOffset |
	radiusOffset := 12 / Float pi.
	aCanvas stroke
		paint: Color gray;
		width: 3;
		path: (aCanvas shape 
				line: radiusOffset @ radiusOffset 
				to: self extent - radiusOffset);
		draw.
	aCanvas stroke
		paint: Color gray;
		width: 3; 
		path: (aCanvas shape
				line: (self width - radiusOffset) @ radiusOffset 
				to: radiusOffset @ (self height - radiusOffset));
		draw 
]]]


+A card with a complete backside.>file://figures/CardFullyClipped.png|width=60|label=figFullClipped+

Now our backside is fully implemented and when you refresh your view, you should get the card 
as shown in Figure *@figFullClipped*. 


!!! Flipped side 

[[[
MgRawCardElement >> drawFlippedSideOnSpartaCanvas: aCanvas
	| font textPainter metrics baseline origin |
	
	font := aCanvas font
		size: 50;
		build.

	textPainter := aCanvas text
		font: font;
		paint: Color white;
		string: self card symbol asString.
	
	metrics := textPainter measure.
	
	origin := (self extent - metrics textMetrics bounds extent) / 2.0.
	baseline := origin - metrics textMetrics bounds origin.
	
	textPainter
		baseline: baseline;
]]]




[[[
MgRawCardElement >> drawFlippedSideOnSpartaCanvas: aCanvas
	| font textPainter metrics baseline origin |
	
	font := aCanvas font
		size: 50;
		build.

	textPainter := aCanvas text
		font: font;
		paint: Color white;
		string: self card symbol asString.
	
	metrics := textPainter measure.
	
	origin := (self extent - metrics textMetrics bounds extent) / 2.0.
	baseline := origin - metrics textMetrics bounds origin.
	
	textPainter
		baseline: baseline;
]]]







!! Adding a board

[[[
BlElement subclass: #MgGameElement
	instanceVariableNames: ''
	classVariableNames: ''
	package: â€˜Bloc-MemoryGame-Elements'
]]]

[[[
MgGameElement >> initialize
	super initialize.
	
	self background: (BlBackground fill: Color gray darker).
	
	self layout: (BlGridLayout horizontal cellSpacing: 20).
	self constraintsDo: [ :layoutConstraints |
		layoutConstraints horizontal fitContent.
		layoutConstraints vertical fitContent ]
]]]

[[[	
MgGameElement >> newCardElement
	^ MgSimpleCardElement new
]]]

[[[
MgGameElement >> memoryGame: aMemoryGame

	self layout columnCount: aMemoryGame gridSize.
	
	aMemoryGame availableCards do: [ :aCard |
		self addChild: (self newCardElement
			card: aCard;
			addEventHandler: (self newCardEventListener
				memoryGame: aMemoryGame)) ].
]]]

[[[
MgGameElement >> newCardEventListener
	^ MgCardEventListener new
]]]

